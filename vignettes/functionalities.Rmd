---
title: "Functionalities of oob"
output:
  md_document:
    variant: markdown_github
  html_document:
    theme: united
vignette: >
  %\VignetteIndexEntry{Functionalities of oob}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::html}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.dim = c(7,7),
  fig.align = "center",
  cache = TRUE,
  warning=FALSE
)
```

# oob: a toolbox for analyzing OMIC data Out Of Bounds

This package provide function for analyzing OMIC data, with a focus on plots, functional enrichment and bulk/single-cell RNA-Seq.

## Installation

In a R console: 

```
install.packages("devtools")
devtools::install_github("https://github.com/DimitriMeistermann/oob", build_vignettes = FALSE)
```
For a manual installation of dependencies:

```
install.packages("BiocManager")
BiocManager::install(c('AnnotationDbi', 'batchelor', 'BiocGenerics', 'BiocManager', 
    'BiocParallel', 'circlize', 'ComplexHeatmap', 'data.table', 'dbscan', 'doParallel', 
    'fgsea', 'foreach', 'gage', 'ggbeeswarm', 'ggplot2', 'ggrepel', 'glmnet', 'impute', 'irlba', 'lsa', 
    'preprocessCore', 'pvclust', 'qualpalr', 'reshape2', 'reticulate', 'rgl', 'scales', 
    'scater', 'scattermore', 'scran', 'SingleCellExperiment', 'stringr', 'SummarizedExperiment', 
    'uwot', 'WGCNA', 'Rcpp', 'RcppArmadillo','basilisk'
))
```



*oob* needs also several python dependencies accessible in the environment used by *reticulate*, the R package for calling python functions. See <https://rstudio.github.io/reticulate/articles/python_packages.html> for more information on installation of python package via reticulate.

For a quick installation:

```
reticulate::py_install(c("numpy","leidenalg","trimap"))
```

#Functionalities of oob

```{r setup}
library(oob)
```

## Data formatting

Fast read and write of text files containing a dataframe or matrix with `fastRead` and `fastWrite`. Default format are tabulated separated value. `chead` is then useful for a quick view of first columns/rows. `rn`, `cn`, `len`, `inter` are respectively aliases for `rownames`, `colnames`, `length` and `intersect`.

```{r}
data("bulkLogCounts") #Bulk RNA-Seq log counts from from Kilens, Meistermann & al 2018

dir.create("test",showWarnings = FALSE)

fastWrite(bulkLogCounts,"test/bulkLogCounts.tsv")
rm(bulkLogCounts)
bulkLogCounts<-fastRead("test/bulkLogCounts.tsv")
chead(bulkLogCounts, n = 10) #quick view of bulkLogCounts

rn(bulkLogCounts)[1:10]
cn(bulkLogCounts)[1:10]
len(rn(bulkLogCounts))
inter(rn(bulkLogCounts)[1:10],rn(bulkLogCounts)[5:15])


```

List of vectors can be processed to factor via `VectorListToFactor` or reciprocally, `factorToVectorList` converts A factor to a list of vectors, where each level is an element and contains the observation names having this level. `read.vectorList` and `write.vectorList` are used to read or write list of vectors in text files.

```{r}
data("DEgenesPrime_Naive") #Differential expression (prime vs naive cell lines) from Kilens, Meistermann & al 2018
genesPerSet<-factorToVectorList(DEgenesPrime_Naive$isDE,factorNames = rn(DEgenesPrime_Naive))
lapply(genesPerSet,head)

write.vectorList(genesPerSet,"test/genesDE.tsv")
read.vectorList("test/genesDE.tsv") |> lapply(head)

top10FC<-rn(DEgenesPrime_Naive)[ whichTop(DEgenesPrime_Naive$log2FoldChange,top = 10) ] #whichTop used here for retrieving top 10 genes in term of log2(Fold-Change)
copyReadyVector(top10FC) #Ready to be copied in a console !
```

When set `set.seed` is used the Random Number Generator give a different result each time it is used. `getRandState`, `setRandState` are used for retrieving/setting this precise seed state.

```{r}
set.seed(666)
rnorm(10)
rnorm(10)
set.seed(666)
rnorm(10)
randState<-getRandState()
rnorm(10)
setRandState(randState)
rnorm(10)
```

## Statistics utilities

The following functions can be applied to a vector of numeric values:

-   `Mode`: (the mode of a distribution)

-   `gmean`: geometrical mean $\sqrt[n]{\prod^n_ix_i}$ - `cv`: coefficient of variation $\sigma/\mu$ - `cv2`: coefficient of variation (squared standard deviation and mean) $\sigma^2/\mu^2$ - `Mode` (most represented value in distribution) - `se`: Standard mean error $\sigma/\sqrt{n}$

-   Distance of correlation $2-cor(x)$ for returning a distance object usable by function of clustering as `hclust`, two can be used:

-   `corrDist`: Method used for computing correlation can be specified. See `method` argument from `cor`.

-   `corrDistBicor`: Correlation is computed following the Biweight midcorrelation method used in WGCNA package. In theory it is better to describe coexpression than Pearson's correlation.

`linearScale` can returned a function able to map one set of value to another

```{r}
minutesTofreqScale<-linearScale(c(0,60),c(0,1))
minutesTofreqScale(30)
```

`reScale` extend the concept of scaling ranges to matrices. A typical use is to put the range of a batch corrected count table from RNA-Seq on the same range than the count table before correction.

```{r}
library(ggplot2)
m1<-matrix(rnorm(100),ncol=50)
p1<-qplotDensity(m1[1,],returnGraph = TRUE)+ggtitle("Distribution of matrix to adjust")
m2<-matrix(rnorm(100,20),ncol=50)
p2<-qplotDensity(m2[1,],returnGraph = TRUE)+ggtitle("Distribution of matrix with target ranges")
m1Rescale<-reScale(m1,m2)
p3<-qplotDensity(m1Rescale[1,],returnGraph = TRUE)+ggtitle("Readjusted matrix")

multiplot(p1,p2,p3,cols = 2) #multiplot for quick display of several plot at once
```

`qplotDensity` used here is a quick plotting function for visualizing distribution. *oob* contains several quick plot wrapper from *ggplot2*: - `qplotAutoX`: Quick plot of a numeric vector with index as x-axis. - `qplotBarplot`: Same but with bars instead of points.

`uncenter` is similar to `reScale` but just shift the values of each feature so the new minimum is 0. `rowScale` scales a matrix in the same way than `scale`, but with rows as features, the common format for RNA-Seq.

`aggregMatPerVector` is 

```{r}
data("sampleAnnot")
aggregMatPerVector(bulkLogCounts[c(
    'KHDC1L','DNMT3L','NLRP7','SPIC','OLAH','MAGEB2'
),], sampleAnnot$culture_media)

```


## Normalization of RNA-Seq

The package can perform several quick normalization methods. Let's simulate a fake count table and attribute real gene symbols as row names.

```{r}
data("geneLengthGRCh38") # vector of gene length for GRCh38 Human reference, named by gene symbols
library(MASS)
countMat<-t(sapply(vector("numeric",length = length(geneLengthGRCh38)),function(x){ #generate a fake RNA-Seq dataset
    rnegbin(10,theta = abs(rnorm(1,mean = 10,sd = 20)),mu = abs(rnorm(1,mean = 10,sd = 20)))
}))
colnames(countMat)<-letters[1:ncol(countMat)];rownames(countMat)<-names(geneLengthGRCh38)
chead(countMat)

#Quality control
computeQCmetricSamples(countMat)

#Different kind of normalization
CPM(countMat) |> chead() #Count Per Million normalization
normDeseq(countMat) |> chead() #DESeq2 normalization
quickSCnorm(countMat) |> chead() #Single-cell (scran) normalization (return log counts by default)
RPKM(countMat,gene.length = geneLengthGRCh38) |> chead() #Reads Per Kilobase per Million (RPKM) normalization for full-length transcript, short read sequencing.
TPMfullLength(countMat,gene.length = geneLengthGRCh38) |> chead() #Transcript per milion (TPM) normalization for full-length transcript, short read sequencing.

```

## Principal Component Analysis tools

Principal Component Analysis can be performed with `PCA` or approximated with `fastPCA` with parametrs optimezed by default for RNA-Seq. Result can be then plotted with `pca2d`.

```{r out.width = "100%", fig.dim = c(16,16)}
data("sampleAnnot") #colData of the count table

PCAres<-PCA(bulkLogCounts)
PCAresQuick<-fastPCA(bulkLogCounts,nPC = 2) # /!\ for fastPCA percentage of explained var is on the total of computed PC (less PC -> increase percentage)
multiplot(
    pca2d(PCAres,returnGraph = TRUE,main = "PCA on bulkLogCounts",colorBy = sampleAnnot$culture_media),
    pca2d(PCAresQuick,returnGraph = TRUE,main = "estimation with fastPCA",colorBy = sampleAnnot$culture_media),
    pca2d(PCAres,plotVars = TRUE,outlierLabel = TRUE,returnGraph = TRUE,main = "Contribution of genes for PC 1 & 2"),
    barplotPercentVar(PCAres,returnGraph = TRUE,nPC = 30)+ggtitle("Scree plot of explained variance per PC"),
    cols = 2
)



```

In the gene contribution plot, `pointdensity.nrd` is used for estimating the 2 density of points. `pcaAddSamples` is another PCA function than can be used to add new samples to the PCA.

For linking experimental variable to principal components we can perform a Principal Component analysis of variance.

```{r}
library(ggbeeswarm)
resPC_aov<-PCaov(PCAres,colData = sampleAnnot[,c("culture_media","line","passage")])

ggBorderedFactors(
    ggplot(resPC_aov,aes(x=PC,y=sumSqPercent,fill= feature))+
        geom_beeswarm(pch=21,size=4,cex = 3)+
        xlab("Principal component")+ylab("% Sum of Squares")+
        scale_fill_manual(values = oobColors(nlevels(resPC_aov$feature)))+
        theme(
            panel.grid.major.y = element_line(colour = "grey75"),
            panel.grid.minor.y = element_line(colour = "grey75"),
            panel.background = element_rect(fill = NA,colour="black")
        )
)

```

The culture media seems to be linked here with PC 1 & 2. Note in the code the use of `mostDistantColor` for generating a color scale with maximum contrast and `ggBorderedFactors` for moving vertical line break between factors in a *ggplot2* function.

## Characterize features of RNA-Seq

We can first filter the count table by computing an overdispersion score for each gene with `getMostVariableGenes`. This function must be executed on a normalized, not log transformed count table. We hence have to "unlog" it.

```{r}
normCount<-2^(bulkLogCounts-1)
dispData<-getMostVariableGenes(normCount,minCount=1)

overdispersedGenes<-rn(dispData)[dispData$residuals>0]
length(overdispersedGenes)
```

We can then compute a PCA on these genes that will result in a reduced dimension space that will be used for downstream analyses.

```{r}
reducedSpace<-t(fastPCA(bulkLogCounts[overdispersedGenes,],nPC = 30))
```

For example, we can perform non linear dimension reductions. Several are provided with the package: `NMDS`, `UMAP` and `TRIMAP`. The result is plotted with `proj2d`.

```{r out.width = "100%", fig.dim = c(16,16)}
reducedSpace<-t(fastPCA(bulkLogCounts[overdispersedGenes,],nPC = 30)$x)
chead(reducedSpace)
coordNMDS<-NMDS(reducedSpace)
coordUMAP<-UMAP(reducedSpace,n_neighbors = ncol(reducedSpace))
coordTRIMAP<-TRIMAP(reducedSpace)

multiplot(cols = 2,
    pca2d(PCAres,colorBy = sampleAnnot$culture_media,returnGraph = TRUE, main = "PCA",ratioPerPercentVar = TRUE),
    proj2d(coordNMDS,colorBy = sampleAnnot$culture_media,returnGraph = TRUE, main = "NMDS",fixedCoord = TRUE),
    proj2d(coordUMAP,colorBy = sampleAnnot$culture_media,returnGraph = TRUE, main = "UMAP",fixedCoord = TRUE),
    proj2d(coordTRIMAP,colorBy = sampleAnnot$culture_media,returnGraph = TRUE, main = "TRIMAP",fixedCoord = TRUE)
)

```

The knn graph used can also be saved when computing the UMAP, and used for a community detection (Leiden) clustering.

```{r}
UMAPwithNN<-UMAP(reducedSpace,n_neighbors = ncol(reducedSpace),ret_nn = TRUE)
sampleAnnot$leidenClusters<-leidenFromUMAP(UMAPwithNN)

proj2d(UMAPwithNN$embedding,colorBy = sampleAnnot$leidenClusters,
             plotFactorsCentroids = TRUE,plotLabelRepel = TRUE,fixedCoord = TRUE, legendTitle = "Leiden cluster")

```

We now pick the best marker per cluster with `getMarkers`, which use the `auroc` function for computing marker scores, along with logFC and p-value.

```{r}
markerPerCluster<-getMarkers(bulkLogCounts[overdispersedGenes,],group = sampleAnnot$leidenClusters)
chead(markerPerCluster)
```

Now we pick up the best marker per cluster, and plot them. Note the log10(n+1) scale accessible as a scale for any ggplot with `log10plus1`.
`extractFeatureMarkerData` is used to extract one value per cluster per gene (by default the marker score).

```{r}
markerScorePerCluster<-extractFeatureMarkerData(markerPerCluster)
head(markerScorePerCluster) #matrix of marker scores

top20MarkerPerCluster<-apply(markerScorePerCluster, 2, function(x) rownames(markerPerCluster)[whichTop(x, top = 20)] ) |> data.frame() |> as.list()

topGenePerCluster<-sapply(top20MarkerPerCluster,function(x) x[1])

plotExpr(normCount[topGenePerCluster,],group = sampleAnnot$leidenClusters, legendTitle = "Leiden cluster")

```

We then used those marker for plotting an heatmap with the dedicated function. 

```{r out.width = "100%", fig.dim = c(14,14)}
htMarker(bulkLogCounts,markerData = markerScorePerCluster,topn = 20 ,group = sampleAnnot$leidenClusters, colData = sampleAnnot[c("culture_media","line")])
```
Note that we can obtain the same result with more struggles using the more general function `heatmap.DM`:

```{r out.width = "100%", fig.dim = c(14,14)}
#convert the list to a factor
top20MarkerFactor<-VectorListToFactor(top20MarkerPerCluster)

#We subsampled the matrix so each cluster give the same number of sample in the heatmap
markEXpressionSubSampled<-subSampleColumnPerGroup(bulkLogCounts[names(top20MarkerFactor),],groupVector = sampleAnnot$leidenClusters)

heatmap.DM(markEXpressionSubSampled, colData = sampleAnnot[cn(markEXpressionSubSampled),c("culture_media","line")],
    column_split=sampleAnnot[cn(markEXpressionSubSampled),"leidenClusters"],row_split=top20MarkerFactor,
    cluster_row_slices = FALSE, cluster_column_slices =FALSE)
#> 
```


`autoGparFontSizeMatrix` is used by `heatmap.DM` to adjust row and column size to the number of samples / features. `heatmap.DM` is a wrapper for `ComplexHeatmap`. It uses `genColorsForAnnots` and `genTopAnnot` are for generating top annotations. The proper heatmap color scale is generated using `computeColorScaleFun` which is able to map colors to percentiles.

Example:

```{r}
values=sort(rnorm(100))
computeColorScaleFun(colors = c("blue","white","red"),values = values,returnColorFun = FALSE,useProb = TRUE, probs = c(.25,.5,.75)) |> 
    plotPalette()
```

`computeColorScaleFun` can also return a ggplot scale if `returnGGscale`.

*oob* features other functions for colors:
-   `oobColors`: Generate pretty and distinct values for a qualitative scale.

-   `mostDistantColor `: Most distant theoretical color palette for a qualitative scale (wrapper for *qualpal*).

-   `ggplotColours`: generate the default colors of *ggplot2*  for a qualitative scale.

-   `convertColorAdd2Sub`: Convert color from additive to subtracting mixing.

Finally, `customUpsetPlot` is used to compare intersection between gene set with an additional value of enrichment. Here we compare the marker of unsupervised cluster and differential expression results between naive and primed pluripotency.

```{r out.width = "100%", fig.dim = c(14,14)}
sets = list(k1 = rn(markerPerCluster)[markerPerCluster$k1.padj < 0.05],
                    k2 = rn(markerPerCluster)[markerPerCluster$k2.padj < 0.05],
                    k3= rn(markerPerCluster)[markerPerCluster$k3.padj < 0.05],
                    primeVSnaiveUP=rn(DEgenesPrime_Naive)[DEgenesPrime_Naive$isDE=="UPREG"],
                    primeVSnaiveDOWN=rn(DEgenesPrime_Naive)[DEgenesPrime_Naive$isDE=="DOWNREG"])

richUpset(sets, universe = rn(markerPerCluster))
```

`volcanoPlot.DESeq2` is designed to show the result of differential expression analysis in the most meaningful way.

```{r}
data("DEgenesPrime_Naive")
volcanoPlot.DESeq2(DEgenesPrime_Naive,formula = "~culture_media+Run",condColumn = "culture_media",downLevel = "KSR+FGF2",upLevel = "T2iLGO")
```

## Other utilities functions:
-     `corGeneToOthers` : Compute the correlation of a gene to all other genes in a matrix.

-        `best.cutree`: Find the best cutree for a hierarchical clustering.

-        `hierarchicalClustering`: Hierarchical clustering from a matrix.

-   `supprNAnames`: Delete row/column in a matrix/df with NA row/colnames

-   `takefirst`: Similar to unique but conserve vector names or return index where you can find each first value of multiple element.

-   `formatAnnotFromMeta`: Format a data frame following metadata. Also add an attribute "colorScale" for mapping colors to the features of the data frame.

-   `formatNumber2Character`: Convert numeric to string, add 0 to the number to respect lexicographical order.

-   `strsplitNth`: Character split with chosen returned element, return a vector.

-   `make.unique2`: Similar to make.unique, but also add a sequence member for the first encountered duplicated element.

-   `matrixCoord1D_2D`: Return the row and column index (2D coordinate) from a 1D coordinate in a matrix.

-   `matrixFromDimnames`: Return the row and column index (2D coordinate) from a 1D coordinate in a matrix.

## Session info

```{r}
sessionInfo()
```

