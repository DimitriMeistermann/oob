% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot.R
\name{heatmap.DM}
\alias{heatmap.DM}
\title{Just a heatmap, but my way...}
\usage{
heatmap.DM(
  matrix,
  preSet = "expr",
  clustering_distance_rows = NULL,
  clustering_distance_columns = "euclidean",
  clustering_method_columns = "ward.D2",
  clustering_method_rows = "ward.D2",
  autoFontSizeRow = TRUE,
  autoFontSizeColumn = TRUE,
  scale = NULL,
  center = NULL,
  returnHeatmap = FALSE,
  name = NULL,
  additionnalRowNamesGpar = NULL,
  additionnalColNamesGpar = list(),
  border = TRUE,
  colorScale = NULL,
  colorScaleFun = NULL,
  midColorIs0 = NULL,
  probs = NULL,
  useProb = TRUE,
  minProb = 0.05,
  maxProb = 0.95,
  cluster_rows = NULL,
  cluster_columns = NULL,
  colData = NULL,
  colorAnnot = NULL,
  showGrid = NULL,
  gparGrid = gpar(col = "black"),
  showValues = FALSE,
  Nsignif = 3,
  column_dend_reorder = FALSE,
  row_dend_reorder = FALSE,
  squareHt = NULL,
  ...
)
}
\arguments{
\item{matrix}{A matrix. Either numeric or character. If it is a simple vector, it will be converted to a one-column matrix.}

\item{preSet}{A value from `"expr"`, `"cor"`, `"dist"` or `NULL`. Change other arguments given a specific preset (default preSet if NULL).}

\item{clustering_distance_rows}{It can be a pre-defined character which is in ("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski", "pearson", "spearman", "kendall").
It can also be a function. If the function has one argument, the input argument should be a matrix and the returned value should be a dist object.
If the function has two arguments, the input arguments are two vectors and the function calculates distance between these two vectors.
In default and expression preset, default value is the `corrDistBicor` function.}

\item{clustering_distance_columns}{Same setting as `clustering_distance_rows`.}

\item{clustering_method_columns}{Method to perform hierarchical clustering, pass to `hclust`.}

\item{clustering_method_rows}{Method to perform hierarchical clustering, pass to `hclust`.}

\item{autoFontSizeRow}{Logical, should row names font size automatically adjusted to the number of row?}

\item{autoFontSizeColumn}{Logical, should column names font size automatically adjusted to the number of columns?}

\item{scale}{Logical. Divide rows of `matrix` by their standard deviation. If NULL determined by preSet.}

\item{center}{Logical. Subtract rows of `matrix` by their average. If NULL determined by preSet.}

\item{returnHeatmap}{Logical, return the plot as a Heatmap object or print it in the current graphical device.}

\item{name}{Character, name of the legend for the main heatmap.}

\item{additionnalRowNamesGpar}{List. Additional parameter passed to `gpar` for row names.}

\item{additionnalColNamesGpar}{List. Additional parameter passed to `gpar` for column names.}

\item{border}{Logical. Whether draw border. The value can be logical or a string of color.}

\item{colorScale}{A vector of colors that will be used for mapping colors to the main heatmap.}

\item{colorScaleFun}{A function that map values to colors. Used for the main heatmap. If not NULL this will supersede the use of the `colorScale` argument.}

\item{midColorIs0}{Logical. Force that 0 is the midColor.  If NULL turned on if the matr.}

\item{probs}{A numeric vector (between 0 and 1) same length as color or NULL. Quantile probability of the values that will be mapped to colors.}

\item{useProb}{Logical. Use quantile probability to map the colors. Else the min and max of values will be mapped to first and last color and interpolated continuously.}

\item{minProb}{A numeric value (between 0 and 1). If `useProb=TRUE` and `probs=NULL` this will be the quantile of the value for the first color, quantile will be mapped continuously as to the maxProb.}

\item{maxProb}{A numeric value (between 0 and 1).}

\item{cluster_rows}{If the value is a logical, it controls whether to make cluster on rows. The value can also be a hclust or a dendrogram which already contains clustering.}

\item{cluster_columns}{Whether make cluster on columns? Same settings as cluster_rows.}

\item{colData}{A vector of factor, character, numeric or logical. Or, a dataframe of any of these type of value. The annotation that will be displayed on the heatmap.}

\item{colorAnnot}{List or NULL. Precomputed color scales for the `colData`. Color scales will be only generated for the features not described.
Must be in the format of a list named by columns of `annots`.
Each element contains the colors at breaks for continuous values.
In the case of factors, the colors are named to their corresponding level or in the order of the levels.}

\item{showGrid}{Logical. Draw a border of each individual square on the heatmap. If NULL automatically true if number of values < 500.}

\item{gparGrid}{Gpar object of the heatmap grid if `showGrid`.}

\item{showValues}{Logical. Show values from the matrix in the middle of each square of the heatmap.}

\item{Nsignif}{Integer. Number of significant digits showed if `showValues`.}

\item{column_dend_reorder}{Apply reordering on column dendrograms. Same settings as row_dend_reorder.}

\item{row_dend_reorder}{Apply reordering on row dendrograms. The value can be a logical value or a vector which contains weight which is used to reorder rows. The reordering is applied by reorder.dendrogram.}

\item{squareHt}{Logical or NULL. Apply clustering columns on rows. If NULL automatically turned TRUE if `ncol==nrow`.}

\item{...}{Other parameters passed to `Heatmap`.}
}
\value{
A Heatmap object if `returnHeatmap` or print the Heatmap in the current graphical device.
}
\description{
Just a heatmap, but my way...
}
\details{
A preSet attributes a list of default values for each argument. However, even if a preSet is selected, arguments precised by the user precede the preSet.
# Default arguments
## preSet is `NULL`
```
clustering_distance_rows = corrDistBicor
name="matrix"
colorScale=c("#2E3672","#4B9AD5","white","#FAB517","#E5261D")
center=TRUE
scale=FALSE
```
## preSet is `"expr"` (expression)
```
clustering_distance_rows = corrDistBicor
name="centered log expression"
colorScale=	c("darkblue","white","red2")
additionnalRowNamesGpar=list(fontface="italic")
center=TRUE
scale=FALSE
```
## preSet is `"cor"` (correlation)
```
clustering_distance_rows ="euclidean"
clustering_distance_columns ="euclidean"
name="Pearson correlation"
colorScale=c("darkblue","white","#FFAA00")
center=FALSE
scale=FALSE
```
## preSet is `"dist" (distance)
```
clustering_distance_rows ="euclidean"
name="Euclidean distance"
colorScale=c("white","yellow","red","purple")
center=FALSE
scale=FALSE
```
}
\examples{
data("bulkLogCounts")
data("sampleAnnot")
data("DEgenesPrime_Naive")

library(ComplexHeatmap)

bestDE<-rownames(DEgenesPrime_Naive)[whichTop(DEgenesPrime_Naive$pvalue,decreasing = FALSE,top = 50)]
heatmap.DM(matrix(rnorm(50),ncol = 5),preSet = NULL,showValues = TRUE,Nsignif = 2)

heatmap.DM(bulkLogCounts[bestDE,],colData = sampleAnnot[,c("culture_media","line")])
heatmap.DM(bulkLogCounts[bestDE[1:5],colnames(sampleAnnot)[sampleAnnot$culture_media]])

corDat<-cor(bulkLogCounts)
heatmap.DM(corDat,preSet = "cor")
heatmap.DM(corDat,preSet = "cor",center = TRUE,colorScaleFun = circlize::colorRamp2(c(-0.2,0,0.2),c("blue","white","red")))
}
